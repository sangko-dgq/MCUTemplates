C251 COMPILER V5.60.0,  BMP390                                                             22/09/22  11:45:02  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE BMP390
OBJECT MODULE PLACED IN .\Objects\BMP390.obj
COMPILER INVOKED BY: D:\Application\Keil_C251\C251\BIN\C251.EXE User\Sensor\BMP390.c XSMALL ROM(HUGE) OPTIMIZE(8,SPEED) 
                    -BROWSE INCDIR(.\User;.\User\oled_gui;.\User\oled_gui\oled_core;.\User\oled_gui\oled_widget;.\User\PageManage;.\User\Sens
                    -or;.\User\System;.\User\Bluetooth) DEBUG PRINT(.\Listings\BMP390.lst) TABS(2) OBJECT(.\Objects\BMP390.obj) 

stmt  level    source

    1          #include "BMP390.h"
    2          #include "IIC.h"
    3          #include "Delay.h"
    4          
    5          /*************************补偿参数*****************************/
    6          //补偿参数，每次上电后从BMP390中读取一次即可
    7          static BMP390_calib_data xdata calib_data;
    8          /*******************未补偿的传感器原始数据*********************/
    9          unsigned long xdata uncomp_pressure;
   10          unsigned long xdata uncomp_temperature;
   11          /**********************设置参数********************************/
   12          static unsigned char xdata BMP390_mode = 0x00;
   13          #define INDOOR_NAVIGATION
   14          #define press_en  0x01
   15          #define temp_en   0x01
   16          #ifdef  HANDEHELD_DEVICE_LOW_POWER
                 //high resolution
                 #define osr_p 0x03  //x8 oversampling
                 #define osr_t 0x00  //x1 oversampling
                 #define iir_filter  2 
                 #define odr_sel 0x04  //12.5Hz
               #endif
   23          #ifdef  HANDEHELD_DEVICE_DYNAMIC
                 //standard resolution
                 #define osr_p 0x02  //x4 oversampling
                 #define osr_t 0x00  //x1 oversampling
                 #define iir_filter  4
                 #define odr_sel 0x02  //50Hz
               #endif
   30          #ifdef  DROP_DETECTION
                 //low power
                 #define osr_p 0x01  //x2 oversampling
                 #define osr_t 0x00  //x1 oversampling
                 #define iir_filter  0
                 #define odr_sel 0x01  //100Hz
               #endif
   37          #ifdef  INDOOR_NAVIGATION
   38            //ultra high resolution
   39            #define osr_p 0x04  //x16 oversampling
   40            #define osr_t 0x01  //x2 oversampling
   41            #define iir_filter  4
   42            #define odr_sel 0x03  //25Hz
   43          #endif
   44          #ifdef  DRONE
                 //standard resolution
                 #define osr_p 0x03  //x8 oversampling
                 #define osr_t 0x00  //x1 oversampling
                 #define iir_filter  2
                 #define odr_sel 0x02  //50Hz
               #endif
   51          /***************************************************************************/
   52          
   53          /**
   54            * @brief  使用IIC总线往BMP390的寄存器中写一字节数据
   55            * @param  addr: 寄存器的地址
   56            * @param  dat:  待写入的数据
   57            * @retval 无
C251 COMPILER V5.60.0,  BMP390                                                             22/09/22  11:45:02  PAGE 2   

   58            */
   59          void BMP390WriteByte(unsigned char addr, unsigned char dat)
   60          {
   61   1        Single_WriteIIC(BMP390_IIC_ADDR, addr, dat);
   62   1      }
   63          /**
   64            * @brief  使用IIC总线从BMP390的寄存器中读一字节数据
   65            * @param  addr: 寄存器的地址
   66            * @retval 读出的一字节数据
   67            */
   68          unsigned char BMP390ReadByte(unsigned char addr)
   69          {
   70   1        unsigned char temp;
   71   1        temp = Single_ReadIIC(BMP390_IIC_ADDR,addr);
   72   1        return temp;
   73   1      }
   74          /**
   75            * @brief  检查与BME280的连接是否正常
   76            * @param  无
   77            * @retval 1（成功），0（失败）
   78            */
   79          unsigned char BMP390CheckConnection(void)
   80          {
   81   1        if(BMP390ReadByte(CHIP_ID) == 0x60)
   82   1          return 1;
   83   1        else
   84   1          return 0;
   85   1      }
   86          /**
   87            * @brief  从BME280中读取补偿参数
   88            *         每次重新上电后调用一次即可
   89            * @param  无
   90            * @retval 无
   91            */
   92          void BMP390ReadCompensationParameter(void)
   93          {
   94   1        unsigned char buf1[21];
   95   1        char int8_temp;
   96   1        int int16_temp;
   97   1        unsigned int uint16_temp;
   98   1        
   99   1        I2C_Read_MultiBytes(BMP390_IIC_ADDR, 0x31, 21, buf1);
  100   1        
  101   1        uint16_temp = (buf1[1] << 8) | buf1[0];
  102   1        calib_data.par_t1 = (float)uint16_temp / 0.00390625; //2^-8
  103   1        
  104   1        uint16_temp = (buf1[3] << 8) | buf1[2];
  105   1        calib_data.par_t2 = (float)uint16_temp / 1073741824;//2^30
  106   1        
  107   1        int8_temp = (char)buf1[4];
  108   1        calib_data.par_t3 = (double)int8_temp / 16777216 / 16777216; //2^24 / 2^24 = 2^48
  109   1        
  110   1        int16_temp = (int)((buf1[6] << 8) | buf1[5]);
  111   1        calib_data.par_p1 = ((float)int16_temp - 16384) / 1048576; //2^14, 2^20
  112   1        
  113   1        int16_temp = (int)((buf1[8] << 8) | buf1[7]); 
  114   1        calib_data.par_p2 = ((float)int16_temp - 16384) / 536870912; //2^14, 2^29
  115   1        
  116   1        int8_temp = (char)buf1[9];
  117   1        calib_data.par_p3 = (float)int8_temp / 65536 / 65536; //2^16 / 2^16
  118   1        
  119   1        int8_temp = (char)buf1[10];
  120   1        calib_data.par_p4 = (float)int8_temp / 65536 / 2097152; //2^16 / 2^21 = 2^37
  121   1        
  122   1        uint16_temp = (buf1[12] << 8) | buf1[11];
  123   1        calib_data.par_p5 = (float)uint16_temp / 0.125; //2^-3
C251 COMPILER V5.60.0,  BMP390                                                             22/09/22  11:45:02  PAGE 3   

  124   1        
  125   1        uint16_temp = (buf1[14] << 8) | buf1[13];
  126   1        calib_data.par_p6 = (float)uint16_temp / 64; //2^6
  127   1        
  128   1        int8_temp = (char)buf1[15];
  129   1        calib_data.par_p7 = (float)int8_temp / 256; //2^8
  130   1        
  131   1        int8_temp = (char)buf1[16];
  132   1        calib_data.par_p8 = (float)int8_temp / 32768; //2^15
  133   1        
  134   1        int16_temp = (int)((buf1[18] << 8) | buf1[17]); 
  135   1        calib_data.par_p9 = (double)int16_temp / 16777216 / 16777216; //2^24 / 2^24 = 2^48
  136   1        
  137   1        int8_temp = (char)buf1[19];
  138   1        calib_data.par_p10 = (double)int8_temp / 16777216 / 16777216; //2^24 / 2^24 = 2^48
  139   1        
  140   1        int8_temp = (char)buf1[20];
  141   1        calib_data.par_p11 = (double)int8_temp / 16777216 / 16777216 / 131072; //2^24 / 2^24 / 2^17 = 2^65
  142   1      }
  143          /**
  144            * @brief  从BME280中读取读传感器原始数据
  145            * @param  无
  146            * @retval 无
  147            */
  148          void BMP390ReadSensorRawData(void)
  149          {
  150   1        unsigned char buf[6];
  151   1        I2C_Read_MultiBytes(BMP390_IIC_ADDR, DATA_0, 6, buf);
  152   1        uncomp_pressure    = ((unsigned long)buf[2] << 16) | ((unsigned long)buf[1] << 8) | buf[0];
  153   1        uncomp_temperature = ((unsigned long)buf[5] << 16) | ((unsigned long)buf[4] << 8) | buf[3];
  154   1      }
  155          /**
  156            * @brief This internal API is used to compensate the raw temperature data and
  157            * return the compensated temperature data in float data type.
  158            */
  159          float compensate_temperature(void)
  160          {
  161   1        float partial_data1;
  162   1        float partial_data2;
  163   1      
  164   1        partial_data1 = (float)(uncomp_temperature - calib_data.par_t1);
  165   1        partial_data2 = (float)(partial_data1 * calib_data.par_t2);
  166   1        calib_data.t_lin = partial_data2 + (partial_data1 * partial_data1) * calib_data.par_t3;
  167   1        return calib_data.t_lin;
  168   1      }
  169          /**
  170            * @brief This internal API is used to compensate the raw pressure data and
  171            * return the compensated pressure data in float data type.
  172            */
  173          float compensate_pressure(void)
  174          {
  175   1        float comp_press;
  176   1        float partial_data1;
  177   1        float partial_data2;
  178   1        float partial_data3;
  179   1        float partial_data4;
  180   1        float partial_out1;
  181   1        float partial_out2;
  182   1        
  183   1        partial_data1 = calib_data.par_p6 * calib_data.t_lin;
  184   1        partial_data2 = calib_data.par_p7 * (calib_data.t_lin * calib_data.t_lin);
  185   1        partial_data3 = calib_data.par_p8 * (calib_data.t_lin * calib_data.t_lin * calib_data.t_lin);
  186   1        partial_out1 = calib_data.par_p5 + partial_data1 + partial_data2 + partial_data3;
  187   1        
  188   1        partial_data1 = calib_data.par_p2 * calib_data.t_lin;
  189   1        partial_data2 = calib_data.par_p3 * (calib_data.t_lin * calib_data.t_lin);
C251 COMPILER V5.60.0,  BMP390                                                             22/09/22  11:45:02  PAGE 4   

  190   1        partial_data3 = calib_data.par_p4 * (calib_data.t_lin * calib_data.t_lin * calib_data.t_lin);
  191   1        partial_out2 = (float)uncomp_pressure * (calib_data.par_p1 + partial_data1 + partial_data2 + partial_dat
             -a3);
  192   1        
  193   1        partial_data1 = (float)uncomp_pressure * (float)uncomp_pressure;
  194   1        partial_data2 = calib_data.par_p9 + calib_data.par_p10 * calib_data.t_lin;
  195   1        partial_data3 = partial_data1 * partial_data2;
  196   1        partial_data4 = partial_data3 + ((float)uncomp_pressure * (float)uncomp_pressure * (float)uncomp_pressur
             -e) * calib_data.par_p11;
  197   1        comp_press = partial_out1 + partial_out2 + partial_data4;
  198   1        
  199   1        return comp_press;
  200   1      }
  201          /**
  202            * @brief  从BMP390中读取读传感器补偿后的数据
  203            * @param  无
  204            * @retval 无
  205            */
  206          void BMP390GetSensorData(t_sBMP390 *p)
  207          {
  208   1        BMP390ReadSensorRawData();
  209   1        p->temperature = compensate_temperature();
  210   1        p->pressure = compensate_pressure();
  211   1      }
  212          /**
  213            * @brief  BMP390软复位
  214            * @param  无
  215            * @retval 无
  216            */
  217          void BMP390SoftReset(void)
  218          {
  219   1        BMP390WriteByte(CMD, 0xB6);
  220   1        Delay1ms(5);
  221   1      }
  222          /**
  223            * @brief 设定BMP390的工作模式
  224            * @param  mode:工作模式选择
  225            *       SLEEP_MODE  睡眠模式（低功耗）
  226            *       FORCED_MODE 单次测量模式
  227            *       NORMAL_MODE 自动连续测量模式
  228            * @retval 无
  229            */
  230          void BMP390SetMode(unsigned char mode)
  231          {
  232   1        BMP390_mode = mode;
  233   1        BMP390WriteByte(PWR_CTRL,  (BMP390_mode << 4) | (temp_en << 1) | press_en);
  234   1      }
  235          /**
  236            * @brief  BMP390初始化函数
  237            * @param  无
  238            * @retval 0：初始化失败
  239            *         1：初始化成功
  240            */
  241          unsigned char BMP390Init()
  242          {
  243   1        unsigned char time_out = 200;
  244   1        //硬件电路上已经将芯片这两个引脚上拉和下拉
  245   1        //故这里无需再设置
  246   1        //CSB = 1;
  247   1        //SDO = 1;
  248   1        Delay1ms(5);
  249   1        while(BMP390CheckConnection() == 0)
  250   1        {
  251   2          Delay1ms(1);
  252   2          if(--time_out == 0)
  253   2            return 0;
C251 COMPILER V5.60.0,  BMP390                                                             22/09/22  11:45:02  PAGE 5   

  254   2        }
  255   1        BMP390SoftReset();
  256   1        BMP390ReadCompensationParameter();
  257   1        BMP390WriteByte(PWR_CTRL,  (BMP390_mode << 4) | (temp_en << 1) | press_en);
  258   1        BMP390WriteByte(OSR, (osr_t << 3) | osr_p);
  259   1        BMP390WriteByte(ODR, odr_sel);
  260   1        BMP390WriteByte(CONFIG, iir_filter << 1);
  261   1        return 1;
  262   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =    ------     ------
  ecode size           =      1330     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        69     ------
  xdata-const size     =    ------     ------
  edata size           =    ------         27
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =         6     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
