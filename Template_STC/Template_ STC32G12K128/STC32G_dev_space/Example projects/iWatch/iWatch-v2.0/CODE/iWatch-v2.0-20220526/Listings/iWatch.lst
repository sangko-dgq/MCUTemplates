C251 COMPILER V5.60.0,  iWatch                                                             24/08/22  19:19:16  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE iWatch
OBJECT MODULE PLACED IN .\Objects\iWatch.obj
COMPILER INVOKED BY: D:\Application\keilC251_v560\C251\BIN\C251.EXE User\iWatch.c XSMALL ROM(HUGE) OPTIMIZE(8,SPEED) BRO
                    -WSE INCDIR(.\User;.\User\oled_gui;.\User\oled_gui\oled_core;.\User\oled_gui\oled_widget;.\User\PageManage;.\User\Sensor;
                    -.\User\System;.\User\Bluetooth) DEBUG PRINT(.\Listings\iWatch.lst) TABS(2) OBJECT(.\Objects\iWatch.obj) 

stmt  level    source

    1          #define __IWATCH_C
    2          #include "iWatch.h"
    3          
    4          /*******************iWatch工作状态相关变量**********************/
    5          static unsigned char xdata t_inactive = 0;  //不活跃的时间，没有动作产生所持续的时长
    6          static unsigned char xdata t_idle = 0;      //空闲状态下持续的时间
    7          static unsigned int xdata autowake_cnt = 0;   //自动唤醒的次数
    8          /***************************************************************/
    9          
   10          void KeyScan(void)          
   11          {
   12   1        static unsigned int t_key_press = 0;  
   13   1        unsigned char dat = 0x00;
   14   1        if(KEY1 == 0)
   15   1          dat |= KEY1_PRESSED;
   16   1        if(KEY2 == 0)
   17   1          dat |= KEY2_PRESSED;
   18   1        if(KEY3 == 0)
   19   1          dat |= KEY3_PRESSED;
   20   1        if(KEY4 == 0)
   21   1          dat |= KEY4_PRESSED;
   22   1        Trg = dat&(dat^Cont);
   23   1        Trg ^= key_mask;
   24   1        key_mask = 0;
   25   1        Cont = dat;
   26   1        if(Cont)
   27   1        {
   28   2          if(++t_key_press > KEY_LONGPRESS_THRESHOLD) //判断是否长按KEY_LONGPRESS_THRESHOLD
   29   2          {
   30   3            Trg = Cont;           //重复触发  
   31   3            t_key_press = KEY_REPEAT_RATE;
   32   3          }
   33   2        }
   34   1        else
   35   1          t_key_press = 0;
   36   1      }
   37          void TM1_Isr() interrupt 3  //MCU定时器1ms中断
   38          {
   39   1        static unsigned int t_cnt = 0;
   40   1        pageTick();
   41   1        og_timeTick();
   42   1        if(t_cnt % KEY_SCAN_T == 0)   //每20ms执行一次按键扫描
   43   1        {
   44   2          KeyScan();
   45   2          if(Trg)
   46   2            iWatch_action = IWATCH_KEYPRESSED;  //产生按键动作
   47   2          if((KEY1 == 0) && (KEY2 == 0))
   48   2          {
   49   3            MCUSoftReset();
   50   3          }
   51   2        }
   52   1        if(++t_cnt == 1000)
   53   1        {
   54   2          t_cnt = 0;
   55   2          iWatchStatusUpdate();   //每秒钟执行一次状态更新
   56   2        }
   57   1      }
C251 COMPILER V5.60.0,  iWatch                                                             24/08/22  19:19:16  PAGE 2   

   58          void INT0_Isr() interrupt 0  //电源线接入中断
   59          {
   60   1        if(PWR_SENSE == 0)
   61   1          iWatch_action = IWATCH_CABLEPLUGININT;
   62   1        else
   63   1          iWatch_action = IWATCH_CABLEUNPLUGINT;
   64   1      }
   65          void INT1_Isr() interrupt 2   //抬腕唤醒中断
   66          {
   67   1        iWatch_action = IWATCH_WRISTUPINT;
   68   1      }
   69          void INT2_Isr() interrupt 10  //RX8130CE中断
   70          {
   71   1        iWatch_action = IWATCH_RTCINT;
   72   1      }
   73          void INT3_Isr() interrupt 11  //按键2中断
   74          {
   75   1        iWatch_action = IWATCH_KEYINT;
   76   1      }
   77          void iWatchStatusUpdate(void)
   78          {
   79   1        if(iWatchCheckStatus(IWATCH_ACTIVE))  
   80   1        {
   81   2          if(config.t_inactive_max == 0)  
   82   2          {
   83   3            iWatchSetStatus(IWATCH_ACTIVE);
   84   3            t_inactive = 0;
   85   3            iWatchClearStatus(IWATCH_IDLE);
   86   3            t_idle = 0;
   87   3          }
   88   2          else
   89   2          {
   90   3            if(++t_inactive >= config.t_inactive_max)
   91   3            {
   92   4              iWatchClearStatus(IWATCH_ACTIVE);
   93   4              t_inactive = 0;
   94   4              iWatchSetStatus(IWATCH_IDLE);
   95   4              t_idle = 0;
   96   4            }
   97   3          }
   98   2        }
   99   1        if(iWatchCheckStatus(IWATCH_IDLE))
  100   1        {
  101   2          if(++t_idle >= 5)
  102   2          {
  103   3            iWatchClearStatus(IWATCH_IDLE);
  104   3            t_idle = 0;
  105   3            iWatchSetStatus(IWATCH_BEFORESLEEP);
  106   3          }
  107   2        }
  108   1      }
  109          void iWatchStatusHandle(void)
  110          {
  111   1        //每当有动作产生（按键被按下，抬腕），action标志位被置1
  112   1        if(iWatch_action != 0)
  113   1        {
  114   2          switch(iWatch_action)
  115   2          {
  116   3            case IWATCH_KEYINT:           //按键中断
  117   3            {
  118   4              if(iWatchCheckStatus(IWATCH_ACTIVE) == 0)
  119   4                key_mask = KEY2_PRESSED;
  120   4              break;
  121   4            }
  122   3            case IWATCH_KEYPRESSED:       //有按键被按下
  123   3            {
C251 COMPILER V5.60.0,  iWatch                                                             24/08/22  19:19:16  PAGE 3   

  124   4              if(config.key_sound)
  125   4                Bee();
  126   4              if(iWatchCheckStatus(IWATCH_ACTIVE) == 0)
  127   4              {
  128   5                Trg = 0;
  129   5              }
  130   4              if(iWatchCheckStatus(IWATCH_ALARMWENTOFF))
  131   4              {
  132   5                Trg = 0;
  133   5                BuzzerOff();
  134   5                iWatchClearStatus(IWATCH_ALARMWENTOFF);
  135   5              }
  136   4              if(Trg)
  137   4                pageEventTransmit(Trg);
  138   4              break;
  139   4            }
  140   3            case IWATCH_WRISTUPINT:       //抬腕唤醒中断
  141   3            {
  142   4              if(iWatchCheckStatus(IWATCH_ACTIVE))
  143   4              {
  144   5                pageEventTransmit(AWT);
  145   5              }
  146   4              break;
  147   4            }
  148   3            case IWATCH_RTCINT:           //外部RTC中断
  149   3            {
  150   4              unsigned char temp = RX8130CEReadIntSrc();        
  151   4              if(temp == RTC_ALARM_INT)
  152   4              {
  153   5                RX8130CEClearAlarmFlag();
  154   5                Beebeebee();      //响铃
  155   5                iWatchSetStatus(IWATCH_ALARMWENTOFF); //置位闹钟标志位
  156   5                Delay1ms(5);
  157   5                RX8130CEAlarmHandle(&config.alarm); //闹钟处理
  158   5                iWatchSaveConfig(&config);
  159   5                break;
  160   5              }
  161   4              if(temp == RTC_TIMER_INT)
  162   4              {
  163   5                RX8130CEClearTimerFlag();
  164   5                RX8130CEReadTime(&time);
  165   5                //battery_life = iWatchGetBatteryLife();
  166   5                if(config.lsm6dsm_cfg & 0x02) //如果计步器功能有开启的话，记录当日步数
  167   5                { 
  168   6                  if((time.hour == 22) && (time.minute == 4))   //22:04,记录当天的步数数据
  169   6                  {
  170   7                    int i;
  171   7                    for(i = 6; i > 0; i--)
  172   7                    {
  173   8                      memcpy((unsigned char *)&(config.step_data[i]), (unsigned char *)&(config.step_data[i- 1]), sizeo
             -f(tsSTEP));
  174   8                    }
  175   7                    config.step_data[0].month = time.month;
  176   7                    config.step_data[0].day = time.day;
  177   7                    config.step_data[0].step = LSM6DSMGetCurrentStep();
  178   7                    LSM6DSMResetStepCounter();
  179   7                    iWatchSaveConfig(&config);
  180   7                  }
  181   6                }
  182   5                autowake_cnt++;
  183   5                iWatch_action = 0;
  184   5                goto Sleep;
  185   5              }
  186   4            }
  187   3            case IWATCH_CABLEPLUGININT:   //充电线接入中断
  188   3              break;
C251 COMPILER V5.60.0,  iWatch                                                             24/08/22  19:19:16  PAGE 4   

  189   3            case IWATCH_CABLEUNPLUGINT:   //充电线断开中断
  190   3            {
  191   4              RX8130CEReadTime(&config.last_charge_time);   //保存最近一次结束充电的时间
  192   4              iWatchSaveConfig(&config);
  193   4              break;  
  194   4            }
  195   3          }
  196   2          iWatch_action = 0;
  197   2          //当有动作被触发后，根据手表所处的状态来进行特定的处理
  198   2          if(iWatchCheckStatus(IWATCH_ACTIVE))
  199   2          {
  200   3            t_inactive = 0;
  201   3          }
  202   2          //如果手表处于空闲状态，退出空闲状态进入活跃状态，屏幕被点亮
  203   2          else if(iWatchCheckStatus(IWATCH_IDLE))
  204   2          {
  205   3            iWatchClearStatus(IWATCH_IDLE);
  206   3            t_idle = 0;
  207   3            iWatchSetStatus(IWATCH_ACTIVE);
  208   3            OLED_Display_On();
  209   3            iWatchSetStatus(IWATCH_SCREENON);
  210   3          }
  211   2          //如果手表处于睡眠状态，退出睡眠状态进入活跃状态，单片机开始开始运转，屏幕被点亮
  212   2          else if(iWatchCheckStatus(IWATCH_SLEEP))
  213   2          {
  214   3            iWatchClearStatus(IWATCH_SLEEP);
  215   3            iWatchSetStatus(IWATCH_ACTIVE);
  216   3            OLED_Display_On();    //点亮屏幕
  217   3            iWatchSetStatus(IWATCH_SCREENON);
  218   3            pageOpenCurrentPage();//打开休眠前关闭的页面
  219   3          }
  220   2          else if(iWatchCheckStatus(IWATCH_POWERDOWN))
  221   2          {
  222   3            MCUSoftReset();
  223   3            /*
  224   3            powerdown_flag = 0;
  225   3            active_flag = 1;
  226   3            SystemWake();         // 唤醒系统
  227   3            DisplayInit();
  228   3            ScreenOnOff(ON);      // 点亮屏幕
  229   3            screen_on_flag = 1;
  230   3            SensorInit();
  231   3            Timer3Init();
  232   3            PageOpenCurrentPage();//打开休眠前关闭的页面
  233   3            */
  234   3          }
  235   2        }
  236   1        if(iWatchCheckStatus((IWATCH_ALARMWENTOFF | IWATCH_TIMERON)))
  237   1        {
  238   2          t_idle = 0;
  239   2        }
  240   1        if(iWatchCheckStatus(IWATCH_IDLE))
  241   1        {
  242   2          if(iWatchCheckStatus(IWATCH_SCREENON))
  243   2          {
  244   3            OLED_Display_Off();
  245   3            iWatchClearStatus(IWATCH_SCREENON);
  246   3          }
  247   2        }
  248   1        if(iWatchCheckStatus(IWATCH_BEFORESLEEP))
  249   1        {
  250   2          iWatchClearStatus(IWATCH_BEFORESLEEP);
  251   2          if(iWatchCheckStatus(IWATCH_SCREENON))
  252   2          {
  253   3            OLED_Display_Off();
  254   3            iWatchClearStatus(IWATCH_SCREENON);
C251 COMPILER V5.60.0,  iWatch                                                             24/08/22  19:19:16  PAGE 5   

  255   3          }
  256   2          pageCloseCurrentPage();
  257   2          iWatchSetStatus(IWATCH_SLEEP);
  258   2        }
  259   1        Sleep:
  260   1        if(iWatchCheckStatus(IWATCH_SLEEP))
  261   1        {
  262   2          if(pageGetStatus() == PAGE_IDLE)  //等待页面关闭后，才进入休眠
  263   2          {
  264   3            SystemSleep();
  265   3            Delay1us(10);
  266   3            SystemWake();
  267   3          }
  268   2        }
  269   1        if(iWatchCheckStatus(IWATCH_POWERDOWN))   
  270   1        {
  271   2          OLED_Display_Off();
  272   2          iWatchClearStatus(IWATCH_SCREENON);
  273   2          SystemPowerDown();
  274   2        }
  275   1      }
  276          void iWatchKeepActive(void)
  277          {
  278   1        iWatchSetStatus(IWATCH_ACTIVE);
  279   1        t_inactive = 0;
  280   1      }
  281          void iWatchSleep(void)
  282          {
  283   1        iWatch_action = 0;
  284   1        iWatchClearStatus(IWATCH_ACTIVE);
  285   1        iWatchClearStatus(IWATCH_IDLE);
  286   1        iWatchClearStatus(IWATCH_POWERDOWN);
  287   1        t_inactive = 0;
  288   1        t_idle = 0;
  289   1        iWatchSetStatus(IWATCH_BEFORESLEEP);
  290   1      }
  291          void iWatchPowerDown(void)
  292          {
  293   1        iWatch_action = 0;
  294   1        iWatchClearStatus(IWATCH_ACTIVE);
  295   1        iWatchClearStatus(IWATCH_IDLE);
  296   1        iWatchClearStatus(IWATCH_POWERDOWN);
  297   1        t_inactive = 0;
  298   1        t_idle = 0;
  299   1        iWatchSetStatus(IWATCH_POWERDOWN);
  300   1      }
  301          void iWatchSaveConfig(iWatch_config *config)
  302          {
  303   1        unsigned int i = 0;
  304   1        unsigned int temp = 0;
  305   1        for(i; i < CONFIG_SIZE - 2; i++)        //对结构体中每一字节求和
  306   1          temp += ((unsigned char *)config)[i];
  307   1        config->check_sum = temp;               //将求和结果存放在结构体最后一个数字中
  308   1        EEPROM_SectorErase(EE_ADDRESS1);        
  309   1        EEPROM_write_n(EE_ADDRESS1, (unsigned char *)config, CONFIG_SIZE);
  310   1      }
  311          
  312          /*从配置从读取配置*/
  313          unsigned char iWatchReadConfig(iWatch_config *config)
  314          {
  315   1        unsigned int i = 0;
  316   1        unsigned int temp = 0;
  317   1        
  318   1        EEPROM_read_n(EE_ADDRESS1, (unsigned char *)config, CONFIG_SIZE);
  319   1        for(i; i < CONFIG_SIZE - 2; i++)        //对结构体中每一字节求和
  320   1          temp += ((unsigned char *)config)[i];
C251 COMPILER V5.60.0,  iWatch                                                             24/08/22  19:19:16  PAGE 6   

  321   1        
  322   1        if((temp == config->check_sum) && (temp != 0))        //检验数据是否正确完整，结构体最后两字节为检验求和字节
  323   1          return 1;
  324   1        else
  325   1        {
  326   2          for(i = 0; i < CONFIG_SIZE; i++)
  327   2            ((unsigned char *)config)[i] = ((unsigned char *)(&default_config))[i];
  328   2          EEPROM_SectorErase(EE_ADDRESS1);  /*擦除EEROM中的数据*/   
  329   2          EEPROM_write_n(EE_ADDRESS1, (unsigned char *)config, CONFIG_SIZE); /*将该配置写入到EEROM*/
  330   2          return 0;
  331   2        }
  332   1      }
  333          /**
  334            * @brief  测量当前电池剩余电量，测量结果已经过窗口滤波
  335            * @param  无
  336            * @retval percentage：剩余电量的百分比
  337            */
  338          #define V_SHUTDOWN    3.4   //放电截止电压
  339          #define V_FULLCHARGE  4.1   //满电电压
  340          #define WINDOW_WIDTH  10    //窗口滤波宽度，适当的宽度使得电压百分比显示比较稳定
  341          float iWatchGetBatteryLife(void)
  342          {
  343   1        static bit first_time_flag = 0;
  344   1        static float queue[WINDOW_WIDTH];   //窗口滤波队列
  345   1        float queue_average = 0;            //队列均值
  346   1        float bat_v;
  347   1        float percentage;                   //电量百分比
  348   1        unsigned char i = 0;
  349   1        bat_v = GetBatVoltage();
  350   1        if(bat_v >= 4.08)
  351   1          percentage = ((bat_v - 4.08) / (V_FULLCHARGE - 4.08)) * 0.1 + 0.9;
  352   1        else if(bat_v >= 4.00)
  353   1          percentage = ((bat_v - 4.00) / (4.08 - 4.00)) * 0.1 + 0.8;
  354   1        else if(bat_v >= 3.93)
  355   1          percentage = ((bat_v - 3.93) / (4.00 - 3.93)) * 0.1 + 0.7;
  356   1        else if(bat_v >= 3.87)
  357   1          percentage = ((bat_v - 3.87) / (3.93 - 3.87)) * 0.1 + 0.6;
  358   1        else if(bat_v >= 3.82)
  359   1          percentage = ((bat_v - 3.82) / (3.87 - 3.82)) * 0.1 + 0.5;
  360   1        else if(bat_v >= 3.79)
  361   1          percentage = ((bat_v - 3.79) / (3.82 - 3.79)) * 0.1 + 0.4;
  362   1        else if(bat_v >= 3.77)
  363   1          percentage = ((bat_v - 3.77) / (3.79 - 3.77)) * 0.1 + 0.3;
  364   1        else if(bat_v >= 3.73)
  365   1          percentage = ((bat_v - 3.73) / (3.77 - 3.73)) * 0.1 + 0.2;
  366   1        else if(bat_v >= 3.70)
  367   1          percentage = ((bat_v - 3.70) / (3.73 - 3.70)) * 0.05 + 0.15;
  368   1        else if(bat_v >= 3.68)
  369   1          percentage = ((bat_v - 3.68) / (3.70 - 3.68)) * 0.05 + 0.1;
  370   1        else if(bat_v >= 3.50)
  371   1          percentage = ((bat_v - 3.50) / (3.68 - 3.50)) * 0.05 + 0.05;
  372   1        else if(bat_v >= V_SHUTDOWN)
  373   1          percentage = ((bat_v - V_SHUTDOWN) / (3.50 - V_SHUTDOWN)) * 0.05;
  374   1        if(percentage > 1)
  375   1          percentage = 1;
  376   1        else if(percentage < 0)
  377   1          percentage = 0;
  378   1        if(first_time_flag == 0)            //若队列中没数据，初始化队列
  379   1        {
  380   2          first_time_flag = 1;
  381   2          for(i = 0; i < WINDOW_WIDTH; i++)
  382   2            queue[i] = percentage;
  383   2        }
  384   1        for(i = WINDOW_WIDTH - 1; i > 0; i--)
  385   1        {
  386   2          queue[i] = queue[i - 1];
C251 COMPILER V5.60.0,  iWatch                                                             24/08/22  19:19:16  PAGE 7   

  387   2          queue_average += queue[i];
  388   2        }
  389   1        queue_average += percentage;
  390   1        percentage = queue_average / WINDOW_WIDTH;
  391   1        queue[0] = percentage;
  392   1        return percentage;
  393   1      }
  394          /**
  395            * @brief  根据当前电量的百分比绘制一个电池图标
  396            * @param  bat：剩余电量的百分比
  397            * @retval 绘制的图标的指针
  398            */
  399          unsigned char *DrawBatteryIcon(float bat)
  400          {
  401   1        unsigned char i, m;
  402   1        if(PWR_SENSE == 0 && CHRG_SENSE == 0) //如果电源线接入且正在充电
  403   1          return BATTERY_CHARGING;            //直接返回一个正在充电的电池图标
  404   1        else
  405   1        {
  406   2          //根据当前电量百分比绘制一个电池图标
  407   2          for(i = 0; i < 24; i++)
  408   2            battery[i + 2] = BATTERY_LIFE_ICON[i];
  409   2          m = 18 * bat;
  410   2          for(i = 2; i < 2 + m; i++)
  411   2            battery[i + 2] |= 0x3c;
  412   2          return battery;
  413   2        }
  414   1      }
  415          
  416          /*传感器初始化*/
  417          void SensorInit(void)
  418          {
  419   1        sensor_status = 0;
  420   1        
  421   1        /*LSM6DM初始化*/
  422   1        if(LSM6DSMInit() != 0)
  423   1        {
  424   2          sensor_status |= LSM6DSM_ISPRESENTED;
  425   2          if(config.lsm6dsm_cfg & 0x01)
  426   2            LSM6DSMEnableAWT(10, 100);        //20 degree, 150ms
  427   2          if(config.lsm6dsm_cfg & 0x02)
  428   2            LSM6DSMEnablePedometer(1040, 6);  //debounce time = 1040ms, debounce step = 6 steps
  429   2        }
  430   1        
  431   1        /*MAG传感器初始化*/
  432   1        #if (MAG_SENSOR_SELECT == 1)
  433   1        if(QMC5883LInit() != 0)
  434   1        {
  435   2          QMC5883LSetCaliValue(&config.mag_cal_Data);
  436   2          sensor_status |= QMC5883L_ISPRESENTED;
  437   2        }
  438   1        #endif
  439   1      
  440   1        /*温度传感器初始化*/
  441   1        #if (TH_SENSOR_SELECT == 1)
                 if(HDC2080Init() != 0)
                   sensor_status |= HDC2080_ISPRESENTED;
                 #elif (TH_SENSOR_SELECT == 2)
                 if(HDC1080Init() != 0)
                   sensor_status |= HDC1080_ISPRESENTED;
                 #elif (TH_SENSOR_SELECT == 3)
  448   1        #endif
  449   1        
  450   1        /*BMP气压传感器初始化*/
  451   1        #if (P_SENSOR_SELECT == 1)
  452   1        if(BMP390Init() != 0)
C251 COMPILER V5.60.0,  iWatch                                                             24/08/22  19:19:16  PAGE 8   

  453   1          sensor_status |= BMP390_ISPRESENTED;
  454   1        #endif
  455   1      }
  456          
  457          /*显示初始化*/
  458          void DisplayInit()
  459          {
  460   1        OLED_Init();
  461   1        OLED_Inverse(config.screen_inverse);
  462   1        OLED_Set_Brightness((config.screen_brightness - 1) * 50 + 1);
*** WARNING C188 IN LINE 462 OF User\iWatch.c: 'parameter 1': value truncated
  463   1      }
  464          
  465          /*iWatch初始化*/
  466          void iWatchInit(void)
  467          {
  468   1        SystemInit();           //系统初始化
  469   1        
  470   1        iWatchReadConfig(&config); /*从EEPROM读取配置*/
  471   1        
  472   1        DisplayInit();          /*显示初始化*/
  473   1        
  474   1        RX8130CEInit();         /* 实时时钟初始化 */
  475   1      
  476   1        SensorInit();
  477   1        
  478   1        /*oled_gui 初始化*/
  479   1        og_init();
  480   1        
  481   1        /*页面初始化*/
  482   1        pageInit();
  483   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       144     ------
  ecode size           =      2757     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       164     ------
  xdata-const size     =    ------     ------
  edata size           =        44          9
  bit size             =         1     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        76     ------
End of Module Information.


C251 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
